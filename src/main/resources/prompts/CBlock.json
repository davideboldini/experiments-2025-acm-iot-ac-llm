{
  "prompts": [
    "Provide ONLY!!!! (NOTHING MORE!!!) a function named C described as follow: Imagine you have a network of devices where each device has a numerical “potential” value (a Double value) and a “local value.” You want to create a function that repeatedly updates a device’s local value by combining it with contributions from its nearby devices—but only including contributions from those devices that consider the current device as their “parent.” (A device becomes a parent of a neighbor if that neighbor, when comparing potentials, finds that the current device has the best (lowest) potential among its neighbors.)\n\nHere’s what the function should do:\n\n1. **Parameters:**\n   - A *potential* value for the current device.\n   - A function (call it *accumulator*) that can combine two values.\n   - A starting or *local value* for the current device.\n   - A *null value* which represents “no contribution” from a neighbor.\n\n2. **Repeated Update Process:**\n   - The device starts with its local value.\n   - It then looks at the values from all its nearby devices.\n   - For each nearby device, if that device has chosen the current device as its parent (based on the potential values), then take that neighbor’s current value. Otherwise, consider its contribution to be the null value.\n   - All these neighbor contributions are then combined together (using the accumulator function) along with the device’s own local value.\n   - This combined result becomes the new value for the device.\n   - The process repeats (updating the device’s value over time) until the values stabilize.\n\n3. **Output:**\n   - The function finally returns the computed value after all the repeated updates.\n\nUsing this plain-language description, please write a function (call it `C`) that has the following signature:\n\n```scala\ndef C[V](potential: Double, acc: (V, V) => V, local: V, Null: V): V = ???\n. REPEAT THE SIGNATURE AND WRITE THE BODY!!!!```"
  ]
}